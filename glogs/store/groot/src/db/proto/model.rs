// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `sdk/model.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct OperationPb {
    // message fields
    pub partitionKey: i64,
    pub opType: OpTypePb,
    pub dataBytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperationPb {
    fn default() -> &'a OperationPb {
        <OperationPb as ::protobuf::Message>::default_instance()
    }
}

impl OperationPb {
    pub fn new() -> OperationPb {
        ::std::default::Default::default()
    }

    // int64 partitionKey = 1;


    pub fn get_partitionKey(&self) -> i64 {
        self.partitionKey
    }
    pub fn clear_partitionKey(&mut self) {
        self.partitionKey = 0;
    }

    // Param is passed by value, moved
    pub fn set_partitionKey(&mut self, v: i64) {
        self.partitionKey = v;
    }

    // .OpTypePb opType = 2;


    pub fn get_opType(&self) -> OpTypePb {
        self.opType
    }
    pub fn clear_opType(&mut self) {
        self.opType = OpTypePb::MARKER;
    }

    // Param is passed by value, moved
    pub fn set_opType(&mut self, v: OpTypePb) {
        self.opType = v;
    }

    // bytes dataBytes = 3;


    pub fn get_dataBytes(&self) -> &[u8] {
        &self.dataBytes
    }
    pub fn clear_dataBytes(&mut self) {
        self.dataBytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataBytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.dataBytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataBytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dataBytes
    }

    // Take field
    pub fn take_dataBytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dataBytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OperationPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.partitionKey = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.opType, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dataBytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.partitionKey != 0 {
            my_size += ::protobuf::rt::value_size(1, self.partitionKey, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.opType != OpTypePb::MARKER {
            my_size += ::protobuf::rt::enum_size(2, self.opType);
        }
        if !self.dataBytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.dataBytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.partitionKey != 0 {
            os.write_int64(1, self.partitionKey)?;
        }
        if self.opType != OpTypePb::MARKER {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.opType))?;
        }
        if !self.dataBytes.is_empty() {
            os.write_bytes(3, &self.dataBytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationPb {
        OperationPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "partitionKey",
                |m: &OperationPb| { &m.partitionKey },
                |m: &mut OperationPb| { &mut m.partitionKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OpTypePb>>(
                "opType",
                |m: &OperationPb| { &m.opType },
                |m: &mut OperationPb| { &mut m.opType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "dataBytes",
                |m: &OperationPb| { &m.dataBytes },
                |m: &mut OperationPb| { &mut m.dataBytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OperationPb>(
                "OperationPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OperationPb {
        static instance: ::protobuf::rt::LazyV2<OperationPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OperationPb::new)
    }
}

impl ::protobuf::Clear for OperationPb {
    fn clear(&mut self) {
        self.partitionKey = 0;
        self.opType = OpTypePb::MARKER;
        self.dataBytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationBatchPb {
    // message fields
    pub latestSnapshotId: i64,
    pub operations: ::protobuf::RepeatedField<OperationPb>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperationBatchPb {
    fn default() -> &'a OperationBatchPb {
        <OperationBatchPb as ::protobuf::Message>::default_instance()
    }
}

impl OperationBatchPb {
    pub fn new() -> OperationBatchPb {
        ::std::default::Default::default()
    }

    // int64 latestSnapshotId = 1;


    pub fn get_latestSnapshotId(&self) -> i64 {
        self.latestSnapshotId
    }
    pub fn clear_latestSnapshotId(&mut self) {
        self.latestSnapshotId = 0;
    }

    // Param is passed by value, moved
    pub fn set_latestSnapshotId(&mut self, v: i64) {
        self.latestSnapshotId = v;
    }

    // repeated .OperationPb operations = 2;


    pub fn get_operations(&self) -> &[OperationPb] {
        &self.operations
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::protobuf::RepeatedField<OperationPb>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::protobuf::RepeatedField<OperationPb> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::protobuf::RepeatedField<OperationPb> {
        ::std::mem::replace(&mut self.operations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OperationBatchPb {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latestSnapshotId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.latestSnapshotId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.latestSnapshotId, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.latestSnapshotId != 0 {
            os.write_int64(1, self.latestSnapshotId)?;
        }
        for v in &self.operations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationBatchPb {
        OperationBatchPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latestSnapshotId",
                |m: &OperationBatchPb| { &m.latestSnapshotId },
                |m: &mut OperationBatchPb| { &mut m.latestSnapshotId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationPb>>(
                "operations",
                |m: &OperationBatchPb| { &m.operations },
                |m: &mut OperationBatchPb| { &mut m.operations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OperationBatchPb>(
                "OperationBatchPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OperationBatchPb {
        static instance: ::protobuf::rt::LazyV2<OperationBatchPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OperationBatchPb::new)
    }
}

impl ::protobuf::Clear for OperationBatchPb {
    fn clear(&mut self) {
        self.latestSnapshotId = 0;
        self.operations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationBatchPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationBatchPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogEntryPb {
    // message fields
    pub snapshotId: i64,
    pub operations: ::protobuf::SingularPtrField<OperationBatchPb>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogEntryPb {
    fn default() -> &'a LogEntryPb {
        <LogEntryPb as ::protobuf::Message>::default_instance()
    }
}

impl LogEntryPb {
    pub fn new() -> LogEntryPb {
        ::std::default::Default::default()
    }

    // int64 snapshotId = 1;


    pub fn get_snapshotId(&self) -> i64 {
        self.snapshotId
    }
    pub fn clear_snapshotId(&mut self) {
        self.snapshotId = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshotId(&mut self, v: i64) {
        self.snapshotId = v;
    }

    // .OperationBatchPb operations = 2;


    pub fn get_operations(&self) -> &OperationBatchPb {
        self.operations.as_ref().unwrap_or_else(|| <OperationBatchPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    pub fn has_operations(&self) -> bool {
        self.operations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: OperationBatchPb) {
        self.operations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operations(&mut self) -> &mut OperationBatchPb {
        if self.operations.is_none() {
            self.operations.set_default();
        }
        self.operations.as_mut().unwrap()
    }

    // Take field
    pub fn take_operations(&mut self) -> OperationBatchPb {
        self.operations.take().unwrap_or_else(|| OperationBatchPb::new())
    }
}

impl ::protobuf::Message for LogEntryPb {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshotId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.operations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshotId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshotId, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.operations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.snapshotId != 0 {
            os.write_int64(1, self.snapshotId)?;
        }
        if let Some(ref v) = self.operations.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogEntryPb {
        LogEntryPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "snapshotId",
                |m: &LogEntryPb| { &m.snapshotId },
                |m: &mut LogEntryPb| { &mut m.snapshotId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationBatchPb>>(
                "operations",
                |m: &LogEntryPb| { &m.operations },
                |m: &mut LogEntryPb| { &mut m.operations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogEntryPb>(
                "LogEntryPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogEntryPb {
        static instance: ::protobuf::rt::LazyV2<LogEntryPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogEntryPb::new)
    }
}

impl ::protobuf::Clear for LogEntryPb {
    fn clear(&mut self) {
        self.snapshotId = 0;
        self.operations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogEntryPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogEntryPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MarkerOperationPb {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarkerOperationPb {
    fn default() -> &'a MarkerOperationPb {
        <MarkerOperationPb as ::protobuf::Message>::default_instance()
    }
}

impl MarkerOperationPb {
    pub fn new() -> MarkerOperationPb {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MarkerOperationPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarkerOperationPb {
        MarkerOperationPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MarkerOperationPb>(
                "MarkerOperationPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MarkerOperationPb {
        static instance: ::protobuf::rt::LazyV2<MarkerOperationPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarkerOperationPb::new)
    }
}

impl ::protobuf::Clear for MarkerOperationPb {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MarkerOperationPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarkerOperationPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PropertyValuePb {
    // message fields
    pub dataType: super::common::DataTypePb,
    pub val: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PropertyValuePb {
    fn default() -> &'a PropertyValuePb {
        <PropertyValuePb as ::protobuf::Message>::default_instance()
    }
}

impl PropertyValuePb {
    pub fn new() -> PropertyValuePb {
        ::std::default::Default::default()
    }

    // .DataTypePb dataType = 1;


    pub fn get_dataType(&self) -> super::common::DataTypePb {
        self.dataType
    }
    pub fn clear_dataType(&mut self) {
        self.dataType = super::common::DataTypePb::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_dataType(&mut self, v: super::common::DataTypePb) {
        self.dataType = v;
    }

    // bytes val = 2;


    pub fn get_val(&self) -> &[u8] {
        &self.val
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::vec::Vec<u8>) {
        self.val = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.val
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.val, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PropertyValuePb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dataType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.val)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dataType != super::common::DataTypePb::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.dataType);
        }
        if !self.val.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.val);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dataType != super::common::DataTypePb::UNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.dataType))?;
        }
        if !self.val.is_empty() {
            os.write_bytes(2, &self.val)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PropertyValuePb {
        PropertyValuePb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::DataTypePb>>(
                "dataType",
                |m: &PropertyValuePb| { &m.dataType },
                |m: &mut PropertyValuePb| { &mut m.dataType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "val",
                |m: &PropertyValuePb| { &m.val },
                |m: &mut PropertyValuePb| { &mut m.val },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PropertyValuePb>(
                "PropertyValuePb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PropertyValuePb {
        static instance: ::protobuf::rt::LazyV2<PropertyValuePb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PropertyValuePb::new)
    }
}

impl ::protobuf::Clear for PropertyValuePb {
    fn clear(&mut self) {
        self.dataType = super::common::DataTypePb::UNKNOWN;
        self.val.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PropertyValuePb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyValuePb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VertexIdPb {
    // message fields
    pub id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VertexIdPb {
    fn default() -> &'a VertexIdPb {
        <VertexIdPb as ::protobuf::Message>::default_instance()
    }
}

impl VertexIdPb {
    pub fn new() -> VertexIdPb {
        ::std::default::Default::default()
    }

    // int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }
}

impl ::protobuf::Message for VertexIdPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VertexIdPb {
        VertexIdPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &VertexIdPb| { &m.id },
                |m: &mut VertexIdPb| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VertexIdPb>(
                "VertexIdPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VertexIdPb {
        static instance: ::protobuf::rt::LazyV2<VertexIdPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VertexIdPb::new)
    }
}

impl ::protobuf::Clear for VertexIdPb {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VertexIdPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexIdPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeIdPb {
    // message fields
    pub srcId: ::protobuf::SingularPtrField<VertexIdPb>,
    pub dstId: ::protobuf::SingularPtrField<VertexIdPb>,
    pub id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EdgeIdPb {
    fn default() -> &'a EdgeIdPb {
        <EdgeIdPb as ::protobuf::Message>::default_instance()
    }
}

impl EdgeIdPb {
    pub fn new() -> EdgeIdPb {
        ::std::default::Default::default()
    }

    // .VertexIdPb srcId = 1;


    pub fn get_srcId(&self) -> &VertexIdPb {
        self.srcId.as_ref().unwrap_or_else(|| <VertexIdPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_srcId(&mut self) {
        self.srcId.clear();
    }

    pub fn has_srcId(&self) -> bool {
        self.srcId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_srcId(&mut self, v: VertexIdPb) {
        self.srcId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_srcId(&mut self) -> &mut VertexIdPb {
        if self.srcId.is_none() {
            self.srcId.set_default();
        }
        self.srcId.as_mut().unwrap()
    }

    // Take field
    pub fn take_srcId(&mut self) -> VertexIdPb {
        self.srcId.take().unwrap_or_else(|| VertexIdPb::new())
    }

    // .VertexIdPb dstId = 2;


    pub fn get_dstId(&self) -> &VertexIdPb {
        self.dstId.as_ref().unwrap_or_else(|| <VertexIdPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dstId(&mut self) {
        self.dstId.clear();
    }

    pub fn has_dstId(&self) -> bool {
        self.dstId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dstId(&mut self, v: VertexIdPb) {
        self.dstId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dstId(&mut self) -> &mut VertexIdPb {
        if self.dstId.is_none() {
            self.dstId.set_default();
        }
        self.dstId.as_mut().unwrap()
    }

    // Take field
    pub fn take_dstId(&mut self) -> VertexIdPb {
        self.dstId.take().unwrap_or_else(|| VertexIdPb::new())
    }

    // int64 id = 3;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }
}

impl ::protobuf::Message for EdgeIdPb {
    fn is_initialized(&self) -> bool {
        for v in &self.srcId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dstId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.srcId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dstId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.srcId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dstId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.srcId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dstId.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.id != 0 {
            os.write_int64(3, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeIdPb {
        EdgeIdPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexIdPb>>(
                "srcId",
                |m: &EdgeIdPb| { &m.srcId },
                |m: &mut EdgeIdPb| { &mut m.srcId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexIdPb>>(
                "dstId",
                |m: &EdgeIdPb| { &m.dstId },
                |m: &mut EdgeIdPb| { &mut m.dstId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &EdgeIdPb| { &m.id },
                |m: &mut EdgeIdPb| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EdgeIdPb>(
                "EdgeIdPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EdgeIdPb {
        static instance: ::protobuf::rt::LazyV2<EdgeIdPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EdgeIdPb::new)
    }
}

impl ::protobuf::Clear for EdgeIdPb {
    fn clear(&mut self) {
        self.srcId.clear();
        self.dstId.clear();
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeIdPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeIdPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabelIdPb {
    // message fields
    pub id: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LabelIdPb {
    fn default() -> &'a LabelIdPb {
        <LabelIdPb as ::protobuf::Message>::default_instance()
    }
}

impl LabelIdPb {
    pub fn new() -> LabelIdPb {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }
}

impl ::protobuf::Message for LabelIdPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabelIdPb {
        LabelIdPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &LabelIdPb| { &m.id },
                |m: &mut LabelIdPb| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LabelIdPb>(
                "LabelIdPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LabelIdPb {
        static instance: ::protobuf::rt::LazyV2<LabelIdPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LabelIdPb::new)
    }
}

impl ::protobuf::Clear for LabelIdPb {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabelIdPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelIdPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeKindPb {
    // message fields
    pub edgeLabel: ::std::string::String,
    pub edgeLabelId: ::protobuf::SingularPtrField<LabelIdPb>,
    pub srcVertexLabel: ::std::string::String,
    pub srcVertexLabelId: ::protobuf::SingularPtrField<LabelIdPb>,
    pub dstVertexLabel: ::std::string::String,
    pub dstVertexLabelId: ::protobuf::SingularPtrField<LabelIdPb>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EdgeKindPb {
    fn default() -> &'a EdgeKindPb {
        <EdgeKindPb as ::protobuf::Message>::default_instance()
    }
}

impl EdgeKindPb {
    pub fn new() -> EdgeKindPb {
        ::std::default::Default::default()
    }

    // string edgeLabel = 1;


    pub fn get_edgeLabel(&self) -> &str {
        &self.edgeLabel
    }
    pub fn clear_edgeLabel(&mut self) {
        self.edgeLabel.clear();
    }

    // Param is passed by value, moved
    pub fn set_edgeLabel(&mut self, v: ::std::string::String) {
        self.edgeLabel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeLabel(&mut self) -> &mut ::std::string::String {
        &mut self.edgeLabel
    }

    // Take field
    pub fn take_edgeLabel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.edgeLabel, ::std::string::String::new())
    }

    // .LabelIdPb edgeLabelId = 2;


    pub fn get_edgeLabelId(&self) -> &LabelIdPb {
        self.edgeLabelId.as_ref().unwrap_or_else(|| <LabelIdPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_edgeLabelId(&mut self) {
        self.edgeLabelId.clear();
    }

    pub fn has_edgeLabelId(&self) -> bool {
        self.edgeLabelId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeLabelId(&mut self, v: LabelIdPb) {
        self.edgeLabelId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeLabelId(&mut self) -> &mut LabelIdPb {
        if self.edgeLabelId.is_none() {
            self.edgeLabelId.set_default();
        }
        self.edgeLabelId.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeLabelId(&mut self) -> LabelIdPb {
        self.edgeLabelId.take().unwrap_or_else(|| LabelIdPb::new())
    }

    // string srcVertexLabel = 3;


    pub fn get_srcVertexLabel(&self) -> &str {
        &self.srcVertexLabel
    }
    pub fn clear_srcVertexLabel(&mut self) {
        self.srcVertexLabel.clear();
    }

    // Param is passed by value, moved
    pub fn set_srcVertexLabel(&mut self, v: ::std::string::String) {
        self.srcVertexLabel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_srcVertexLabel(&mut self) -> &mut ::std::string::String {
        &mut self.srcVertexLabel
    }

    // Take field
    pub fn take_srcVertexLabel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.srcVertexLabel, ::std::string::String::new())
    }

    // .LabelIdPb srcVertexLabelId = 4;


    pub fn get_srcVertexLabelId(&self) -> &LabelIdPb {
        self.srcVertexLabelId.as_ref().unwrap_or_else(|| <LabelIdPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_srcVertexLabelId(&mut self) {
        self.srcVertexLabelId.clear();
    }

    pub fn has_srcVertexLabelId(&self) -> bool {
        self.srcVertexLabelId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_srcVertexLabelId(&mut self, v: LabelIdPb) {
        self.srcVertexLabelId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_srcVertexLabelId(&mut self) -> &mut LabelIdPb {
        if self.srcVertexLabelId.is_none() {
            self.srcVertexLabelId.set_default();
        }
        self.srcVertexLabelId.as_mut().unwrap()
    }

    // Take field
    pub fn take_srcVertexLabelId(&mut self) -> LabelIdPb {
        self.srcVertexLabelId.take().unwrap_or_else(|| LabelIdPb::new())
    }

    // string dstVertexLabel = 5;


    pub fn get_dstVertexLabel(&self) -> &str {
        &self.dstVertexLabel
    }
    pub fn clear_dstVertexLabel(&mut self) {
        self.dstVertexLabel.clear();
    }

    // Param is passed by value, moved
    pub fn set_dstVertexLabel(&mut self, v: ::std::string::String) {
        self.dstVertexLabel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dstVertexLabel(&mut self) -> &mut ::std::string::String {
        &mut self.dstVertexLabel
    }

    // Take field
    pub fn take_dstVertexLabel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dstVertexLabel, ::std::string::String::new())
    }

    // .LabelIdPb dstVertexLabelId = 6;


    pub fn get_dstVertexLabelId(&self) -> &LabelIdPb {
        self.dstVertexLabelId.as_ref().unwrap_or_else(|| <LabelIdPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dstVertexLabelId(&mut self) {
        self.dstVertexLabelId.clear();
    }

    pub fn has_dstVertexLabelId(&self) -> bool {
        self.dstVertexLabelId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dstVertexLabelId(&mut self, v: LabelIdPb) {
        self.dstVertexLabelId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dstVertexLabelId(&mut self) -> &mut LabelIdPb {
        if self.dstVertexLabelId.is_none() {
            self.dstVertexLabelId.set_default();
        }
        self.dstVertexLabelId.as_mut().unwrap()
    }

    // Take field
    pub fn take_dstVertexLabelId(&mut self) -> LabelIdPb {
        self.dstVertexLabelId.take().unwrap_or_else(|| LabelIdPb::new())
    }
}

impl ::protobuf::Message for EdgeKindPb {
    fn is_initialized(&self) -> bool {
        for v in &self.edgeLabelId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.srcVertexLabelId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dstVertexLabelId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.edgeLabel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeLabelId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.srcVertexLabel)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.srcVertexLabelId)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dstVertexLabel)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dstVertexLabelId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.edgeLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.edgeLabel);
        }
        if let Some(ref v) = self.edgeLabelId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.srcVertexLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.srcVertexLabel);
        }
        if let Some(ref v) = self.srcVertexLabelId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.dstVertexLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.dstVertexLabel);
        }
        if let Some(ref v) = self.dstVertexLabelId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.edgeLabel.is_empty() {
            os.write_string(1, &self.edgeLabel)?;
        }
        if let Some(ref v) = self.edgeLabelId.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.srcVertexLabel.is_empty() {
            os.write_string(3, &self.srcVertexLabel)?;
        }
        if let Some(ref v) = self.srcVertexLabelId.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.dstVertexLabel.is_empty() {
            os.write_string(5, &self.dstVertexLabel)?;
        }
        if let Some(ref v) = self.dstVertexLabelId.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeKindPb {
        EdgeKindPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "edgeLabel",
                |m: &EdgeKindPb| { &m.edgeLabel },
                |m: &mut EdgeKindPb| { &mut m.edgeLabel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelIdPb>>(
                "edgeLabelId",
                |m: &EdgeKindPb| { &m.edgeLabelId },
                |m: &mut EdgeKindPb| { &mut m.edgeLabelId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "srcVertexLabel",
                |m: &EdgeKindPb| { &m.srcVertexLabel },
                |m: &mut EdgeKindPb| { &mut m.srcVertexLabel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelIdPb>>(
                "srcVertexLabelId",
                |m: &EdgeKindPb| { &m.srcVertexLabelId },
                |m: &mut EdgeKindPb| { &mut m.srcVertexLabelId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dstVertexLabel",
                |m: &EdgeKindPb| { &m.dstVertexLabel },
                |m: &mut EdgeKindPb| { &mut m.dstVertexLabel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelIdPb>>(
                "dstVertexLabelId",
                |m: &EdgeKindPb| { &m.dstVertexLabelId },
                |m: &mut EdgeKindPb| { &mut m.dstVertexLabelId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EdgeKindPb>(
                "EdgeKindPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EdgeKindPb {
        static instance: ::protobuf::rt::LazyV2<EdgeKindPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EdgeKindPb::new)
    }
}

impl ::protobuf::Clear for EdgeKindPb {
    fn clear(&mut self) {
        self.edgeLabel.clear();
        self.edgeLabelId.clear();
        self.srcVertexLabel.clear();
        self.srcVertexLabelId.clear();
        self.dstVertexLabel.clear();
        self.dstVertexLabelId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeKindPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeKindPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeLocationPb {
    // message fields
    pub edgeKind: ::protobuf::SingularPtrField<EdgeKindPb>,
    pub forward: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EdgeLocationPb {
    fn default() -> &'a EdgeLocationPb {
        <EdgeLocationPb as ::protobuf::Message>::default_instance()
    }
}

impl EdgeLocationPb {
    pub fn new() -> EdgeLocationPb {
        ::std::default::Default::default()
    }

    // .EdgeKindPb edgeKind = 1;


    pub fn get_edgeKind(&self) -> &EdgeKindPb {
        self.edgeKind.as_ref().unwrap_or_else(|| <EdgeKindPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_edgeKind(&mut self) {
        self.edgeKind.clear();
    }

    pub fn has_edgeKind(&self) -> bool {
        self.edgeKind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeKind(&mut self, v: EdgeKindPb) {
        self.edgeKind = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeKind(&mut self) -> &mut EdgeKindPb {
        if self.edgeKind.is_none() {
            self.edgeKind.set_default();
        }
        self.edgeKind.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeKind(&mut self) -> EdgeKindPb {
        self.edgeKind.take().unwrap_or_else(|| EdgeKindPb::new())
    }

    // bool forward = 2;


    pub fn get_forward(&self) -> bool {
        self.forward
    }
    pub fn clear_forward(&mut self) {
        self.forward = false;
    }

    // Param is passed by value, moved
    pub fn set_forward(&mut self, v: bool) {
        self.forward = v;
    }
}

impl ::protobuf::Message for EdgeLocationPb {
    fn is_initialized(&self) -> bool {
        for v in &self.edgeKind {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeKind)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forward = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.edgeKind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.forward != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.edgeKind.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.forward != false {
            os.write_bool(2, self.forward)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeLocationPb {
        EdgeLocationPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeKindPb>>(
                "edgeKind",
                |m: &EdgeLocationPb| { &m.edgeKind },
                |m: &mut EdgeLocationPb| { &mut m.edgeKind },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "forward",
                |m: &EdgeLocationPb| { &m.forward },
                |m: &mut EdgeLocationPb| { &mut m.forward },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EdgeLocationPb>(
                "EdgeLocationPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EdgeLocationPb {
        static instance: ::protobuf::rt::LazyV2<EdgeLocationPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EdgeLocationPb::new)
    }
}

impl ::protobuf::Clear for EdgeLocationPb {
    fn clear(&mut self) {
        self.edgeKind.clear();
        self.forward = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeLocationPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeLocationPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataOperationPb {
    // message fields
    pub keyBlob: ::std::vec::Vec<u8>,
    pub locationBlob: ::std::vec::Vec<u8>,
    pub props: ::std::collections::HashMap<i32, PropertyValuePb>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataOperationPb {
    fn default() -> &'a DataOperationPb {
        <DataOperationPb as ::protobuf::Message>::default_instance()
    }
}

impl DataOperationPb {
    pub fn new() -> DataOperationPb {
        ::std::default::Default::default()
    }

    // bytes keyBlob = 1;


    pub fn get_keyBlob(&self) -> &[u8] {
        &self.keyBlob
    }
    pub fn clear_keyBlob(&mut self) {
        self.keyBlob.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyBlob(&mut self, v: ::std::vec::Vec<u8>) {
        self.keyBlob = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyBlob(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.keyBlob
    }

    // Take field
    pub fn take_keyBlob(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.keyBlob, ::std::vec::Vec::new())
    }

    // bytes locationBlob = 2;


    pub fn get_locationBlob(&self) -> &[u8] {
        &self.locationBlob
    }
    pub fn clear_locationBlob(&mut self) {
        self.locationBlob.clear();
    }

    // Param is passed by value, moved
    pub fn set_locationBlob(&mut self, v: ::std::vec::Vec<u8>) {
        self.locationBlob = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locationBlob(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.locationBlob
    }

    // Take field
    pub fn take_locationBlob(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.locationBlob, ::std::vec::Vec::new())
    }

    // repeated .DataOperationPb.PropsEntry props = 3;


    pub fn get_props(&self) -> &::std::collections::HashMap<i32, PropertyValuePb> {
        &self.props
    }
    pub fn clear_props(&mut self) {
        self.props.clear();
    }

    // Param is passed by value, moved
    pub fn set_props(&mut self, v: ::std::collections::HashMap<i32, PropertyValuePb>) {
        self.props = v;
    }

    // Mutable pointer to the field.
    pub fn mut_props(&mut self) -> &mut ::std::collections::HashMap<i32, PropertyValuePb> {
        &mut self.props
    }

    // Take field
    pub fn take_props(&mut self) -> ::std::collections::HashMap<i32, PropertyValuePb> {
        ::std::mem::replace(&mut self.props, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for DataOperationPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.keyBlob)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.locationBlob)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(wire_type, is, &mut self.props)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.keyBlob.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.keyBlob);
        }
        if !self.locationBlob.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.locationBlob);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(3, &self.props);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.keyBlob.is_empty() {
            os.write_bytes(1, &self.keyBlob)?;
        }
        if !self.locationBlob.is_empty() {
            os.write_bytes(2, &self.locationBlob)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(3, &self.props, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataOperationPb {
        DataOperationPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "keyBlob",
                |m: &DataOperationPb| { &m.keyBlob },
                |m: &mut DataOperationPb| { &mut m.keyBlob },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "locationBlob",
                |m: &DataOperationPb| { &m.locationBlob },
                |m: &mut DataOperationPb| { &mut m.locationBlob },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(
                "props",
                |m: &DataOperationPb| { &m.props },
                |m: &mut DataOperationPb| { &mut m.props },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataOperationPb>(
                "DataOperationPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataOperationPb {
        static instance: ::protobuf::rt::LazyV2<DataOperationPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataOperationPb::new)
    }
}

impl ::protobuf::Clear for DataOperationPb {
    fn clear(&mut self) {
        self.keyBlob.clear();
        self.locationBlob.clear();
        self.props.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataOperationPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataOperationPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KindOperationPb {
    // message fields
    pub edgeKind: ::protobuf::SingularPtrField<EdgeKindPb>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KindOperationPb {
    fn default() -> &'a KindOperationPb {
        <KindOperationPb as ::protobuf::Message>::default_instance()
    }
}

impl KindOperationPb {
    pub fn new() -> KindOperationPb {
        ::std::default::Default::default()
    }

    // .EdgeKindPb edgeKind = 1;


    pub fn get_edgeKind(&self) -> &EdgeKindPb {
        self.edgeKind.as_ref().unwrap_or_else(|| <EdgeKindPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_edgeKind(&mut self) {
        self.edgeKind.clear();
    }

    pub fn has_edgeKind(&self) -> bool {
        self.edgeKind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeKind(&mut self, v: EdgeKindPb) {
        self.edgeKind = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeKind(&mut self) -> &mut EdgeKindPb {
        if self.edgeKind.is_none() {
            self.edgeKind.set_default();
        }
        self.edgeKind.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeKind(&mut self) -> EdgeKindPb {
        self.edgeKind.take().unwrap_or_else(|| EdgeKindPb::new())
    }
}

impl ::protobuf::Message for KindOperationPb {
    fn is_initialized(&self) -> bool {
        for v in &self.edgeKind {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeKind)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.edgeKind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.edgeKind.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KindOperationPb {
        KindOperationPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeKindPb>>(
                "edgeKind",
                |m: &KindOperationPb| { &m.edgeKind },
                |m: &mut KindOperationPb| { &mut m.edgeKind },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KindOperationPb>(
                "KindOperationPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KindOperationPb {
        static instance: ::protobuf::rt::LazyV2<KindOperationPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KindOperationPb::new)
    }
}

impl ::protobuf::Clear for KindOperationPb {
    fn clear(&mut self) {
        self.edgeKind.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KindOperationPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KindOperationPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeDefPb {
    // message fields
    pub versionId: i32,
    pub label: ::std::string::String,
    pub labelId: ::protobuf::SingularPtrField<LabelIdPb>,
    pub typeEnum: TypeEnumPb,
    pub props: ::protobuf::RepeatedField<PropertyDefPb>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeDefPb {
    fn default() -> &'a TypeDefPb {
        <TypeDefPb as ::protobuf::Message>::default_instance()
    }
}

impl TypeDefPb {
    pub fn new() -> TypeDefPb {
        ::std::default::Default::default()
    }

    // int32 versionId = 1;


    pub fn get_versionId(&self) -> i32 {
        self.versionId
    }
    pub fn clear_versionId(&mut self) {
        self.versionId = 0;
    }

    // Param is passed by value, moved
    pub fn set_versionId(&mut self, v: i32) {
        self.versionId = v;
    }

    // string label = 2;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // .LabelIdPb labelId = 3;


    pub fn get_labelId(&self) -> &LabelIdPb {
        self.labelId.as_ref().unwrap_or_else(|| <LabelIdPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_labelId(&mut self) {
        self.labelId.clear();
    }

    pub fn has_labelId(&self) -> bool {
        self.labelId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelId(&mut self, v: LabelIdPb) {
        self.labelId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelId(&mut self) -> &mut LabelIdPb {
        if self.labelId.is_none() {
            self.labelId.set_default();
        }
        self.labelId.as_mut().unwrap()
    }

    // Take field
    pub fn take_labelId(&mut self) -> LabelIdPb {
        self.labelId.take().unwrap_or_else(|| LabelIdPb::new())
    }

    // .TypeEnumPb typeEnum = 4;


    pub fn get_typeEnum(&self) -> TypeEnumPb {
        self.typeEnum
    }
    pub fn clear_typeEnum(&mut self) {
        self.typeEnum = TypeEnumPb::VERTEX;
    }

    // Param is passed by value, moved
    pub fn set_typeEnum(&mut self, v: TypeEnumPb) {
        self.typeEnum = v;
    }

    // repeated .PropertyDefPb props = 5;


    pub fn get_props(&self) -> &[PropertyDefPb] {
        &self.props
    }
    pub fn clear_props(&mut self) {
        self.props.clear();
    }

    // Param is passed by value, moved
    pub fn set_props(&mut self, v: ::protobuf::RepeatedField<PropertyDefPb>) {
        self.props = v;
    }

    // Mutable pointer to the field.
    pub fn mut_props(&mut self) -> &mut ::protobuf::RepeatedField<PropertyDefPb> {
        &mut self.props
    }

    // Take field
    pub fn take_props(&mut self) -> ::protobuf::RepeatedField<PropertyDefPb> {
        ::std::mem::replace(&mut self.props, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TypeDefPb {
    fn is_initialized(&self) -> bool {
        for v in &self.labelId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.props {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labelId)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.typeEnum, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.props)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.versionId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.versionId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if let Some(ref v) = self.labelId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.typeEnum != TypeEnumPb::VERTEX {
            my_size += ::protobuf::rt::enum_size(4, self.typeEnum);
        }
        for value in &self.props {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.versionId != 0 {
            os.write_int32(1, self.versionId)?;
        }
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if let Some(ref v) = self.labelId.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.typeEnum != TypeEnumPb::VERTEX {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.typeEnum))?;
        }
        for v in &self.props {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeDefPb {
        TypeDefPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionId",
                |m: &TypeDefPb| { &m.versionId },
                |m: &mut TypeDefPb| { &mut m.versionId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &TypeDefPb| { &m.label },
                |m: &mut TypeDefPb| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelIdPb>>(
                "labelId",
                |m: &TypeDefPb| { &m.labelId },
                |m: &mut TypeDefPb| { &mut m.labelId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TypeEnumPb>>(
                "typeEnum",
                |m: &TypeDefPb| { &m.typeEnum },
                |m: &mut TypeDefPb| { &mut m.typeEnum },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyDefPb>>(
                "props",
                |m: &TypeDefPb| { &m.props },
                |m: &mut TypeDefPb| { &mut m.props },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TypeDefPb>(
                "TypeDefPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TypeDefPb {
        static instance: ::protobuf::rt::LazyV2<TypeDefPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypeDefPb::new)
    }
}

impl ::protobuf::Clear for TypeDefPb {
    fn clear(&mut self) {
        self.versionId = 0;
        self.label.clear();
        self.labelId.clear();
        self.typeEnum = TypeEnumPb::VERTEX;
        self.props.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeDefPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeDefPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PropertyDefPb {
    // message fields
    pub id: i32,
    pub innerId: i32,
    pub name: ::std::string::String,
    pub dataType: super::common::DataTypePb,
    pub defaultValue: ::protobuf::SingularPtrField<PropertyValuePb>,
    pub pk: bool,
    pub comment: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PropertyDefPb {
    fn default() -> &'a PropertyDefPb {
        <PropertyDefPb as ::protobuf::Message>::default_instance()
    }
}

impl PropertyDefPb {
    pub fn new() -> PropertyDefPb {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // int32 innerId = 2;


    pub fn get_innerId(&self) -> i32 {
        self.innerId
    }
    pub fn clear_innerId(&mut self) {
        self.innerId = 0;
    }

    // Param is passed by value, moved
    pub fn set_innerId(&mut self, v: i32) {
        self.innerId = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .DataTypePb dataType = 4;


    pub fn get_dataType(&self) -> super::common::DataTypePb {
        self.dataType
    }
    pub fn clear_dataType(&mut self) {
        self.dataType = super::common::DataTypePb::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_dataType(&mut self, v: super::common::DataTypePb) {
        self.dataType = v;
    }

    // .PropertyValuePb defaultValue = 5;


    pub fn get_defaultValue(&self) -> &PropertyValuePb {
        self.defaultValue.as_ref().unwrap_or_else(|| <PropertyValuePb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_defaultValue(&mut self) {
        self.defaultValue.clear();
    }

    pub fn has_defaultValue(&self) -> bool {
        self.defaultValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultValue(&mut self, v: PropertyValuePb) {
        self.defaultValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defaultValue(&mut self) -> &mut PropertyValuePb {
        if self.defaultValue.is_none() {
            self.defaultValue.set_default();
        }
        self.defaultValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_defaultValue(&mut self) -> PropertyValuePb {
        self.defaultValue.take().unwrap_or_else(|| PropertyValuePb::new())
    }

    // bool pk = 6;


    pub fn get_pk(&self) -> bool {
        self.pk
    }
    pub fn clear_pk(&mut self) {
        self.pk = false;
    }

    // Param is passed by value, moved
    pub fn set_pk(&mut self, v: bool) {
        self.pk = v;
    }

    // string comment = 7;


    pub fn get_comment(&self) -> &str {
        &self.comment
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        &mut self.comment
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comment, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PropertyDefPb {
    fn is_initialized(&self) -> bool {
        for v in &self.defaultValue {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.innerId = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dataType, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.defaultValue)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pk = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.innerId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.innerId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if self.dataType != super::common::DataTypePb::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(4, self.dataType);
        }
        if let Some(ref v) = self.defaultValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.pk != false {
            my_size += 2;
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.comment);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.innerId != 0 {
            os.write_int32(2, self.innerId)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if self.dataType != super::common::DataTypePb::UNKNOWN {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.dataType))?;
        }
        if let Some(ref v) = self.defaultValue.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.pk != false {
            os.write_bool(6, self.pk)?;
        }
        if !self.comment.is_empty() {
            os.write_string(7, &self.comment)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PropertyDefPb {
        PropertyDefPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &PropertyDefPb| { &m.id },
                |m: &mut PropertyDefPb| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "innerId",
                |m: &PropertyDefPb| { &m.innerId },
                |m: &mut PropertyDefPb| { &mut m.innerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PropertyDefPb| { &m.name },
                |m: &mut PropertyDefPb| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::DataTypePb>>(
                "dataType",
                |m: &PropertyDefPb| { &m.dataType },
                |m: &mut PropertyDefPb| { &mut m.dataType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(
                "defaultValue",
                |m: &PropertyDefPb| { &m.defaultValue },
                |m: &mut PropertyDefPb| { &mut m.defaultValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pk",
                |m: &PropertyDefPb| { &m.pk },
                |m: &mut PropertyDefPb| { &mut m.pk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "comment",
                |m: &PropertyDefPb| { &m.comment },
                |m: &mut PropertyDefPb| { &mut m.comment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PropertyDefPb>(
                "PropertyDefPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PropertyDefPb {
        static instance: ::protobuf::rt::LazyV2<PropertyDefPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PropertyDefPb::new)
    }
}

impl ::protobuf::Clear for PropertyDefPb {
    fn clear(&mut self) {
        self.id = 0;
        self.innerId = 0;
        self.name.clear();
        self.dataType = super::common::DataTypePb::UNKNOWN;
        self.defaultValue.clear();
        self.pk = false;
        self.comment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PropertyDefPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyDefPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DdlRequestPb {
    // message fields
    pub opType: OpTypePb,
    pub ddlBytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DdlRequestPb {
    fn default() -> &'a DdlRequestPb {
        <DdlRequestPb as ::protobuf::Message>::default_instance()
    }
}

impl DdlRequestPb {
    pub fn new() -> DdlRequestPb {
        ::std::default::Default::default()
    }

    // .OpTypePb opType = 1;


    pub fn get_opType(&self) -> OpTypePb {
        self.opType
    }
    pub fn clear_opType(&mut self) {
        self.opType = OpTypePb::MARKER;
    }

    // Param is passed by value, moved
    pub fn set_opType(&mut self, v: OpTypePb) {
        self.opType = v;
    }

    // bytes ddlBytes = 2;


    pub fn get_ddlBytes(&self) -> &[u8] {
        &self.ddlBytes
    }
    pub fn clear_ddlBytes(&mut self) {
        self.ddlBytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_ddlBytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.ddlBytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ddlBytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ddlBytes
    }

    // Take field
    pub fn take_ddlBytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ddlBytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DdlRequestPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.opType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ddlBytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.opType != OpTypePb::MARKER {
            my_size += ::protobuf::rt::enum_size(1, self.opType);
        }
        if !self.ddlBytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ddlBytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.opType != OpTypePb::MARKER {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.opType))?;
        }
        if !self.ddlBytes.is_empty() {
            os.write_bytes(2, &self.ddlBytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DdlRequestPb {
        DdlRequestPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OpTypePb>>(
                "opType",
                |m: &DdlRequestPb| { &m.opType },
                |m: &mut DdlRequestPb| { &mut m.opType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ddlBytes",
                |m: &DdlRequestPb| { &m.ddlBytes },
                |m: &mut DdlRequestPb| { &mut m.ddlBytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DdlRequestPb>(
                "DdlRequestPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DdlRequestPb {
        static instance: ::protobuf::rt::LazyV2<DdlRequestPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DdlRequestPb::new)
    }
}

impl ::protobuf::Clear for DdlRequestPb {
    fn clear(&mut self) {
        self.opType = OpTypePb::MARKER;
        self.ddlBytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DdlRequestPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DdlRequestPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DdlRequestBatchPb {
    // message fields
    pub ddlRequests: ::protobuf::RepeatedField<DdlRequestPb>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DdlRequestBatchPb {
    fn default() -> &'a DdlRequestBatchPb {
        <DdlRequestBatchPb as ::protobuf::Message>::default_instance()
    }
}

impl DdlRequestBatchPb {
    pub fn new() -> DdlRequestBatchPb {
        ::std::default::Default::default()
    }

    // repeated .DdlRequestPb ddlRequests = 1;


    pub fn get_ddlRequests(&self) -> &[DdlRequestPb] {
        &self.ddlRequests
    }
    pub fn clear_ddlRequests(&mut self) {
        self.ddlRequests.clear();
    }

    // Param is passed by value, moved
    pub fn set_ddlRequests(&mut self, v: ::protobuf::RepeatedField<DdlRequestPb>) {
        self.ddlRequests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ddlRequests(&mut self) -> &mut ::protobuf::RepeatedField<DdlRequestPb> {
        &mut self.ddlRequests
    }

    // Take field
    pub fn take_ddlRequests(&mut self) -> ::protobuf::RepeatedField<DdlRequestPb> {
        ::std::mem::replace(&mut self.ddlRequests, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DdlRequestBatchPb {
    fn is_initialized(&self) -> bool {
        for v in &self.ddlRequests {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ddlRequests)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ddlRequests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ddlRequests {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DdlRequestBatchPb {
        DdlRequestBatchPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DdlRequestPb>>(
                "ddlRequests",
                |m: &DdlRequestBatchPb| { &m.ddlRequests },
                |m: &mut DdlRequestBatchPb| { &mut m.ddlRequests },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DdlRequestBatchPb>(
                "DdlRequestBatchPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DdlRequestBatchPb {
        static instance: ::protobuf::rt::LazyV2<DdlRequestBatchPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DdlRequestBatchPb::new)
    }
}

impl ::protobuf::Clear for DdlRequestBatchPb {
    fn clear(&mut self) {
        self.ddlRequests.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DdlRequestBatchPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DdlRequestBatchPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DdlOperationPb {
    // message fields
    pub schemaVersion: i64,
    pub ddlBlob: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DdlOperationPb {
    fn default() -> &'a DdlOperationPb {
        <DdlOperationPb as ::protobuf::Message>::default_instance()
    }
}

impl DdlOperationPb {
    pub fn new() -> DdlOperationPb {
        ::std::default::Default::default()
    }

    // int64 schemaVersion = 1;


    pub fn get_schemaVersion(&self) -> i64 {
        self.schemaVersion
    }
    pub fn clear_schemaVersion(&mut self) {
        self.schemaVersion = 0;
    }

    // Param is passed by value, moved
    pub fn set_schemaVersion(&mut self, v: i64) {
        self.schemaVersion = v;
    }

    // bytes ddlBlob = 2;


    pub fn get_ddlBlob(&self) -> &[u8] {
        &self.ddlBlob
    }
    pub fn clear_ddlBlob(&mut self) {
        self.ddlBlob.clear();
    }

    // Param is passed by value, moved
    pub fn set_ddlBlob(&mut self, v: ::std::vec::Vec<u8>) {
        self.ddlBlob = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ddlBlob(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ddlBlob
    }

    // Take field
    pub fn take_ddlBlob(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ddlBlob, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DdlOperationPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.schemaVersion = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ddlBlob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.schemaVersion != 0 {
            my_size += ::protobuf::rt::value_size(1, self.schemaVersion, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ddlBlob.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ddlBlob);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.schemaVersion != 0 {
            os.write_int64(1, self.schemaVersion)?;
        }
        if !self.ddlBlob.is_empty() {
            os.write_bytes(2, &self.ddlBlob)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DdlOperationPb {
        DdlOperationPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "schemaVersion",
                |m: &DdlOperationPb| { &m.schemaVersion },
                |m: &mut DdlOperationPb| { &mut m.schemaVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ddlBlob",
                |m: &DdlOperationPb| { &m.ddlBlob },
                |m: &mut DdlOperationPb| { &mut m.ddlBlob },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DdlOperationPb>(
                "DdlOperationPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DdlOperationPb {
        static instance: ::protobuf::rt::LazyV2<DdlOperationPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DdlOperationPb::new)
    }
}

impl ::protobuf::Clear for DdlOperationPb {
    fn clear(&mut self) {
        self.schemaVersion = 0;
        self.ddlBlob.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DdlOperationPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DdlOperationPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateVertexTypePb {
    // message fields
    pub typeDef: ::protobuf::SingularPtrField<TypeDefPb>,
    pub tableIdx: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateVertexTypePb {
    fn default() -> &'a CreateVertexTypePb {
        <CreateVertexTypePb as ::protobuf::Message>::default_instance()
    }
}

impl CreateVertexTypePb {
    pub fn new() -> CreateVertexTypePb {
        ::std::default::Default::default()
    }

    // .TypeDefPb typeDef = 1;


    pub fn get_typeDef(&self) -> &TypeDefPb {
        self.typeDef.as_ref().unwrap_or_else(|| <TypeDefPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_typeDef(&mut self) {
        self.typeDef.clear();
    }

    pub fn has_typeDef(&self) -> bool {
        self.typeDef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeDef(&mut self, v: TypeDefPb) {
        self.typeDef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typeDef(&mut self) -> &mut TypeDefPb {
        if self.typeDef.is_none() {
            self.typeDef.set_default();
        }
        self.typeDef.as_mut().unwrap()
    }

    // Take field
    pub fn take_typeDef(&mut self) -> TypeDefPb {
        self.typeDef.take().unwrap_or_else(|| TypeDefPb::new())
    }

    // int64 tableIdx = 2;


    pub fn get_tableIdx(&self) -> i64 {
        self.tableIdx
    }
    pub fn clear_tableIdx(&mut self) {
        self.tableIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_tableIdx(&mut self, v: i64) {
        self.tableIdx = v;
    }
}

impl ::protobuf::Message for CreateVertexTypePb {
    fn is_initialized(&self) -> bool {
        for v in &self.typeDef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.typeDef)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tableIdx = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.typeDef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.tableIdx != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tableIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.typeDef.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.tableIdx != 0 {
            os.write_int64(2, self.tableIdx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateVertexTypePb {
        CreateVertexTypePb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeDefPb>>(
                "typeDef",
                |m: &CreateVertexTypePb| { &m.typeDef },
                |m: &mut CreateVertexTypePb| { &mut m.typeDef },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tableIdx",
                |m: &CreateVertexTypePb| { &m.tableIdx },
                |m: &mut CreateVertexTypePb| { &mut m.tableIdx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateVertexTypePb>(
                "CreateVertexTypePb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateVertexTypePb {
        static instance: ::protobuf::rt::LazyV2<CreateVertexTypePb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateVertexTypePb::new)
    }
}

impl ::protobuf::Clear for CreateVertexTypePb {
    fn clear(&mut self) {
        self.typeDef.clear();
        self.tableIdx = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateVertexTypePb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateVertexTypePb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddEdgeKindPb {
    // message fields
    pub edgeKind: ::protobuf::SingularPtrField<EdgeKindPb>,
    pub tableIdx: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddEdgeKindPb {
    fn default() -> &'a AddEdgeKindPb {
        <AddEdgeKindPb as ::protobuf::Message>::default_instance()
    }
}

impl AddEdgeKindPb {
    pub fn new() -> AddEdgeKindPb {
        ::std::default::Default::default()
    }

    // .EdgeKindPb edgeKind = 1;


    pub fn get_edgeKind(&self) -> &EdgeKindPb {
        self.edgeKind.as_ref().unwrap_or_else(|| <EdgeKindPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_edgeKind(&mut self) {
        self.edgeKind.clear();
    }

    pub fn has_edgeKind(&self) -> bool {
        self.edgeKind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeKind(&mut self, v: EdgeKindPb) {
        self.edgeKind = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeKind(&mut self) -> &mut EdgeKindPb {
        if self.edgeKind.is_none() {
            self.edgeKind.set_default();
        }
        self.edgeKind.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeKind(&mut self) -> EdgeKindPb {
        self.edgeKind.take().unwrap_or_else(|| EdgeKindPb::new())
    }

    // int64 tableIdx = 2;


    pub fn get_tableIdx(&self) -> i64 {
        self.tableIdx
    }
    pub fn clear_tableIdx(&mut self) {
        self.tableIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_tableIdx(&mut self, v: i64) {
        self.tableIdx = v;
    }
}

impl ::protobuf::Message for AddEdgeKindPb {
    fn is_initialized(&self) -> bool {
        for v in &self.edgeKind {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeKind)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tableIdx = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.edgeKind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.tableIdx != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tableIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.edgeKind.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.tableIdx != 0 {
            os.write_int64(2, self.tableIdx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddEdgeKindPb {
        AddEdgeKindPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeKindPb>>(
                "edgeKind",
                |m: &AddEdgeKindPb| { &m.edgeKind },
                |m: &mut AddEdgeKindPb| { &mut m.edgeKind },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tableIdx",
                |m: &AddEdgeKindPb| { &m.tableIdx },
                |m: &mut AddEdgeKindPb| { &mut m.tableIdx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddEdgeKindPb>(
                "AddEdgeKindPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddEdgeKindPb {
        static instance: ::protobuf::rt::LazyV2<AddEdgeKindPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddEdgeKindPb::new)
    }
}

impl ::protobuf::Clear for AddEdgeKindPb {
    fn clear(&mut self) {
        self.edgeKind.clear();
        self.tableIdx = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddEdgeKindPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddEdgeKindPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeTableIdEntry {
    // message fields
    pub edgeKind: ::protobuf::SingularPtrField<EdgeKindPb>,
    pub tableId: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EdgeTableIdEntry {
    fn default() -> &'a EdgeTableIdEntry {
        <EdgeTableIdEntry as ::protobuf::Message>::default_instance()
    }
}

impl EdgeTableIdEntry {
    pub fn new() -> EdgeTableIdEntry {
        ::std::default::Default::default()
    }

    // .EdgeKindPb edgeKind = 1;


    pub fn get_edgeKind(&self) -> &EdgeKindPb {
        self.edgeKind.as_ref().unwrap_or_else(|| <EdgeKindPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_edgeKind(&mut self) {
        self.edgeKind.clear();
    }

    pub fn has_edgeKind(&self) -> bool {
        self.edgeKind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edgeKind(&mut self, v: EdgeKindPb) {
        self.edgeKind = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edgeKind(&mut self) -> &mut EdgeKindPb {
        if self.edgeKind.is_none() {
            self.edgeKind.set_default();
        }
        self.edgeKind.as_mut().unwrap()
    }

    // Take field
    pub fn take_edgeKind(&mut self) -> EdgeKindPb {
        self.edgeKind.take().unwrap_or_else(|| EdgeKindPb::new())
    }

    // int64 tableId = 2;


    pub fn get_tableId(&self) -> i64 {
        self.tableId
    }
    pub fn clear_tableId(&mut self) {
        self.tableId = 0;
    }

    // Param is passed by value, moved
    pub fn set_tableId(&mut self, v: i64) {
        self.tableId = v;
    }
}

impl ::protobuf::Message for EdgeTableIdEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.edgeKind {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edgeKind)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tableId = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.edgeKind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.tableId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tableId, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.edgeKind.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.tableId != 0 {
            os.write_int64(2, self.tableId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeTableIdEntry {
        EdgeTableIdEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeKindPb>>(
                "edgeKind",
                |m: &EdgeTableIdEntry| { &m.edgeKind },
                |m: &mut EdgeTableIdEntry| { &mut m.edgeKind },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tableId",
                |m: &EdgeTableIdEntry| { &m.tableId },
                |m: &mut EdgeTableIdEntry| { &mut m.tableId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EdgeTableIdEntry>(
                "EdgeTableIdEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EdgeTableIdEntry {
        static instance: ::protobuf::rt::LazyV2<EdgeTableIdEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EdgeTableIdEntry::new)
    }
}

impl ::protobuf::Clear for EdgeTableIdEntry {
    fn clear(&mut self) {
        self.edgeKind.clear();
        self.tableId = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeTableIdEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeTableIdEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VertexTableIdEntry {
    // message fields
    pub labelId: ::protobuf::SingularPtrField<LabelIdPb>,
    pub tableId: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VertexTableIdEntry {
    fn default() -> &'a VertexTableIdEntry {
        <VertexTableIdEntry as ::protobuf::Message>::default_instance()
    }
}

impl VertexTableIdEntry {
    pub fn new() -> VertexTableIdEntry {
        ::std::default::Default::default()
    }

    // .LabelIdPb labelId = 1;


    pub fn get_labelId(&self) -> &LabelIdPb {
        self.labelId.as_ref().unwrap_or_else(|| <LabelIdPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_labelId(&mut self) {
        self.labelId.clear();
    }

    pub fn has_labelId(&self) -> bool {
        self.labelId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelId(&mut self, v: LabelIdPb) {
        self.labelId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelId(&mut self) -> &mut LabelIdPb {
        if self.labelId.is_none() {
            self.labelId.set_default();
        }
        self.labelId.as_mut().unwrap()
    }

    // Take field
    pub fn take_labelId(&mut self) -> LabelIdPb {
        self.labelId.take().unwrap_or_else(|| LabelIdPb::new())
    }

    // int64 tableId = 2;


    pub fn get_tableId(&self) -> i64 {
        self.tableId
    }
    pub fn clear_tableId(&mut self) {
        self.tableId = 0;
    }

    // Param is passed by value, moved
    pub fn set_tableId(&mut self, v: i64) {
        self.tableId = v;
    }
}

impl ::protobuf::Message for VertexTableIdEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.labelId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labelId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tableId = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.labelId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.tableId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tableId, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.labelId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.tableId != 0 {
            os.write_int64(2, self.tableId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VertexTableIdEntry {
        VertexTableIdEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelIdPb>>(
                "labelId",
                |m: &VertexTableIdEntry| { &m.labelId },
                |m: &mut VertexTableIdEntry| { &mut m.labelId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tableId",
                |m: &VertexTableIdEntry| { &m.tableId },
                |m: &mut VertexTableIdEntry| { &mut m.tableId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VertexTableIdEntry>(
                "VertexTableIdEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VertexTableIdEntry {
        static instance: ::protobuf::rt::LazyV2<VertexTableIdEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VertexTableIdEntry::new)
    }
}

impl ::protobuf::Clear for VertexTableIdEntry {
    fn clear(&mut self) {
        self.labelId.clear();
        self.tableId = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VertexTableIdEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexTableIdEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphDefPb {
    // message fields
    pub version: i64,
    pub typeDefs: ::protobuf::RepeatedField<TypeDefPb>,
    pub edgeKinds: ::protobuf::RepeatedField<EdgeKindPb>,
    pub propertyNameToId: ::std::collections::HashMap<::std::string::String, i32>,
    pub labelIdx: i32,
    pub propertyIdx: i32,
    pub vertexTableIds: ::protobuf::RepeatedField<VertexTableIdEntry>,
    pub edgeTableIds: ::protobuf::RepeatedField<EdgeTableIdEntry>,
    pub tableIdx: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GraphDefPb {
    fn default() -> &'a GraphDefPb {
        <GraphDefPb as ::protobuf::Message>::default_instance()
    }
}

impl GraphDefPb {
    pub fn new() -> GraphDefPb {
        ::std::default::Default::default()
    }

    // int64 version = 1;


    pub fn get_version(&self) -> i64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i64) {
        self.version = v;
    }

    // repeated .TypeDefPb typeDefs = 2;


    pub fn get_typeDefs(&self) -> &[TypeDefPb] {
        &self.typeDefs
    }
    pub fn clear_typeDefs(&mut self) {
        self.typeDefs.clear();
    }

    // Param is passed by value, moved
    pub fn set_typeDefs(&mut self, v: ::protobuf::RepeatedField<TypeDefPb>) {
        self.typeDefs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_typeDefs(&mut self) -> &mut ::protobuf::RepeatedField<TypeDefPb> {
        &mut self.typeDefs
    }

    // Take field
    pub fn take_typeDefs(&mut self) -> ::protobuf::RepeatedField<TypeDefPb> {
        ::std::mem::replace(&mut self.typeDefs, ::protobuf::RepeatedField::new())
    }

    // repeated .EdgeKindPb edgeKinds = 3;


    pub fn get_edgeKinds(&self) -> &[EdgeKindPb] {
        &self.edgeKinds
    }
    pub fn clear_edgeKinds(&mut self) {
        self.edgeKinds.clear();
    }

    // Param is passed by value, moved
    pub fn set_edgeKinds(&mut self, v: ::protobuf::RepeatedField<EdgeKindPb>) {
        self.edgeKinds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edgeKinds(&mut self) -> &mut ::protobuf::RepeatedField<EdgeKindPb> {
        &mut self.edgeKinds
    }

    // Take field
    pub fn take_edgeKinds(&mut self) -> ::protobuf::RepeatedField<EdgeKindPb> {
        ::std::mem::replace(&mut self.edgeKinds, ::protobuf::RepeatedField::new())
    }

    // repeated .GraphDefPb.PropertyNameToIdEntry propertyNameToId = 4;


    pub fn get_propertyNameToId(&self) -> &::std::collections::HashMap<::std::string::String, i32> {
        &self.propertyNameToId
    }
    pub fn clear_propertyNameToId(&mut self) {
        self.propertyNameToId.clear();
    }

    // Param is passed by value, moved
    pub fn set_propertyNameToId(&mut self, v: ::std::collections::HashMap<::std::string::String, i32>) {
        self.propertyNameToId = v;
    }

    // Mutable pointer to the field.
    pub fn mut_propertyNameToId(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i32> {
        &mut self.propertyNameToId
    }

    // Take field
    pub fn take_propertyNameToId(&mut self) -> ::std::collections::HashMap<::std::string::String, i32> {
        ::std::mem::replace(&mut self.propertyNameToId, ::std::collections::HashMap::new())
    }

    // int32 labelIdx = 5;


    pub fn get_labelIdx(&self) -> i32 {
        self.labelIdx
    }
    pub fn clear_labelIdx(&mut self) {
        self.labelIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_labelIdx(&mut self, v: i32) {
        self.labelIdx = v;
    }

    // int32 propertyIdx = 6;


    pub fn get_propertyIdx(&self) -> i32 {
        self.propertyIdx
    }
    pub fn clear_propertyIdx(&mut self) {
        self.propertyIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_propertyIdx(&mut self, v: i32) {
        self.propertyIdx = v;
    }

    // repeated .VertexTableIdEntry vertexTableIds = 7;


    pub fn get_vertexTableIds(&self) -> &[VertexTableIdEntry] {
        &self.vertexTableIds
    }
    pub fn clear_vertexTableIds(&mut self) {
        self.vertexTableIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_vertexTableIds(&mut self, v: ::protobuf::RepeatedField<VertexTableIdEntry>) {
        self.vertexTableIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vertexTableIds(&mut self) -> &mut ::protobuf::RepeatedField<VertexTableIdEntry> {
        &mut self.vertexTableIds
    }

    // Take field
    pub fn take_vertexTableIds(&mut self) -> ::protobuf::RepeatedField<VertexTableIdEntry> {
        ::std::mem::replace(&mut self.vertexTableIds, ::protobuf::RepeatedField::new())
    }

    // repeated .EdgeTableIdEntry edgeTableIds = 8;


    pub fn get_edgeTableIds(&self) -> &[EdgeTableIdEntry] {
        &self.edgeTableIds
    }
    pub fn clear_edgeTableIds(&mut self) {
        self.edgeTableIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_edgeTableIds(&mut self, v: ::protobuf::RepeatedField<EdgeTableIdEntry>) {
        self.edgeTableIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edgeTableIds(&mut self) -> &mut ::protobuf::RepeatedField<EdgeTableIdEntry> {
        &mut self.edgeTableIds
    }

    // Take field
    pub fn take_edgeTableIds(&mut self) -> ::protobuf::RepeatedField<EdgeTableIdEntry> {
        ::std::mem::replace(&mut self.edgeTableIds, ::protobuf::RepeatedField::new())
    }

    // int64 tableIdx = 9;


    pub fn get_tableIdx(&self) -> i64 {
        self.tableIdx
    }
    pub fn clear_tableIdx(&mut self) {
        self.tableIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_tableIdx(&mut self, v: i64) {
        self.tableIdx = v;
    }
}

impl ::protobuf::Message for GraphDefPb {
    fn is_initialized(&self) -> bool {
        for v in &self.typeDefs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edgeKinds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vertexTableIds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edgeTableIds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.version = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.typeDefs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edgeKinds)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.propertyNameToId)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.labelIdx = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.propertyIdx = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vertexTableIds)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edgeTableIds)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tableIdx = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.typeDefs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.edgeKinds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(4, &self.propertyNameToId);
        if self.labelIdx != 0 {
            my_size += ::protobuf::rt::value_size(5, self.labelIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.propertyIdx != 0 {
            my_size += ::protobuf::rt::value_size(6, self.propertyIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.vertexTableIds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.edgeTableIds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.tableIdx != 0 {
            my_size += ::protobuf::rt::value_size(9, self.tableIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.version != 0 {
            os.write_int64(1, self.version)?;
        }
        for v in &self.typeDefs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.edgeKinds {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(4, &self.propertyNameToId, os)?;
        if self.labelIdx != 0 {
            os.write_int32(5, self.labelIdx)?;
        }
        if self.propertyIdx != 0 {
            os.write_int32(6, self.propertyIdx)?;
        }
        for v in &self.vertexTableIds {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.edgeTableIds {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.tableIdx != 0 {
            os.write_int64(9, self.tableIdx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphDefPb {
        GraphDefPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "version",
                |m: &GraphDefPb| { &m.version },
                |m: &mut GraphDefPb| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeDefPb>>(
                "typeDefs",
                |m: &GraphDefPb| { &m.typeDefs },
                |m: &mut GraphDefPb| { &mut m.typeDefs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeKindPb>>(
                "edgeKinds",
                |m: &GraphDefPb| { &m.edgeKinds },
                |m: &mut GraphDefPb| { &mut m.edgeKinds },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(
                "propertyNameToId",
                |m: &GraphDefPb| { &m.propertyNameToId },
                |m: &mut GraphDefPb| { &mut m.propertyNameToId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "labelIdx",
                |m: &GraphDefPb| { &m.labelIdx },
                |m: &mut GraphDefPb| { &mut m.labelIdx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "propertyIdx",
                |m: &GraphDefPb| { &m.propertyIdx },
                |m: &mut GraphDefPb| { &mut m.propertyIdx },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexTableIdEntry>>(
                "vertexTableIds",
                |m: &GraphDefPb| { &m.vertexTableIds },
                |m: &mut GraphDefPb| { &mut m.vertexTableIds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeTableIdEntry>>(
                "edgeTableIds",
                |m: &GraphDefPb| { &m.edgeTableIds },
                |m: &mut GraphDefPb| { &mut m.edgeTableIds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tableIdx",
                |m: &GraphDefPb| { &m.tableIdx },
                |m: &mut GraphDefPb| { &mut m.tableIdx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GraphDefPb>(
                "GraphDefPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GraphDefPb {
        static instance: ::protobuf::rt::LazyV2<GraphDefPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GraphDefPb::new)
    }
}

impl ::protobuf::Clear for GraphDefPb {
    fn clear(&mut self) {
        self.version = 0;
        self.typeDefs.clear();
        self.edgeKinds.clear();
        self.propertyNameToId.clear();
        self.labelIdx = 0;
        self.propertyIdx = 0;
        self.vertexTableIds.clear();
        self.edgeTableIds.clear();
        self.tableIdx = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphDefPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphDefPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorePropertyPb {
    // message fields
    pub property_id: i32,
    pub property_value: ::protobuf::SingularPtrField<PropertyValuePb>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorePropertyPb {
    fn default() -> &'a StorePropertyPb {
        <StorePropertyPb as ::protobuf::Message>::default_instance()
    }
}

impl StorePropertyPb {
    pub fn new() -> StorePropertyPb {
        ::std::default::Default::default()
    }

    // int32 property_id = 1;


    pub fn get_property_id(&self) -> i32 {
        self.property_id
    }
    pub fn clear_property_id(&mut self) {
        self.property_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_id(&mut self, v: i32) {
        self.property_id = v;
    }

    // .PropertyValuePb property_value = 2;


    pub fn get_property_value(&self) -> &PropertyValuePb {
        self.property_value.as_ref().unwrap_or_else(|| <PropertyValuePb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_property_value(&mut self) {
        self.property_value.clear();
    }

    pub fn has_property_value(&self) -> bool {
        self.property_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_property_value(&mut self, v: PropertyValuePb) {
        self.property_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_property_value(&mut self) -> &mut PropertyValuePb {
        if self.property_value.is_none() {
            self.property_value.set_default();
        }
        self.property_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_property_value(&mut self) -> PropertyValuePb {
        self.property_value.take().unwrap_or_else(|| PropertyValuePb::new())
    }
}

impl ::protobuf::Message for StorePropertyPb {
    fn is_initialized(&self) -> bool {
        for v in &self.property_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.property_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.property_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.property_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.property_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.property_id != 0 {
            os.write_int32(1, self.property_id)?;
        }
        if let Some(ref v) = self.property_value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorePropertyPb {
        StorePropertyPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "property_id",
                |m: &StorePropertyPb| { &m.property_id },
                |m: &mut StorePropertyPb| { &mut m.property_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyValuePb>>(
                "property_value",
                |m: &StorePropertyPb| { &m.property_value },
                |m: &mut StorePropertyPb| { &mut m.property_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorePropertyPb>(
                "StorePropertyPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorePropertyPb {
        static instance: ::protobuf::rt::LazyV2<StorePropertyPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorePropertyPb::new)
    }
}

impl ::protobuf::Clear for StorePropertyPb {
    fn clear(&mut self) {
        self.property_id = 0;
        self.property_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorePropertyPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorePropertyPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorePropertyListPb {
    // message fields
    pub properties: ::protobuf::RepeatedField<StorePropertyPb>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorePropertyListPb {
    fn default() -> &'a StorePropertyListPb {
        <StorePropertyListPb as ::protobuf::Message>::default_instance()
    }
}

impl StorePropertyListPb {
    pub fn new() -> StorePropertyListPb {
        ::std::default::Default::default()
    }

    // repeated .StorePropertyPb properties = 1;


    pub fn get_properties(&self) -> &[StorePropertyPb] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<StorePropertyPb>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<StorePropertyPb> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<StorePropertyPb> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StorePropertyListPb {
    fn is_initialized(&self) -> bool {
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.properties {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorePropertyListPb {
        StorePropertyListPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorePropertyPb>>(
                "properties",
                |m: &StorePropertyListPb| { &m.properties },
                |m: &mut StorePropertyListPb| { &mut m.properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorePropertyListPb>(
                "StorePropertyListPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorePropertyListPb {
        static instance: ::protobuf::rt::LazyV2<StorePropertyListPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorePropertyListPb::new)
    }
}

impl ::protobuf::Clear for StorePropertyListPb {
    fn clear(&mut self) {
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorePropertyListPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorePropertyListPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigPb {
    // message fields
    pub configs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigPb {
    fn default() -> &'a ConfigPb {
        <ConfigPb as ::protobuf::Message>::default_instance()
    }
}

impl ConfigPb {
    pub fn new() -> ConfigPb {
        ::std::default::Default::default()
    }

    // repeated .ConfigPb.ConfigsEntry configs = 1;


    pub fn get_configs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.configs
    }
    pub fn clear_configs(&mut self) {
        self.configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_configs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_configs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.configs
    }

    // Take field
    pub fn take_configs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.configs, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ConfigPb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.configs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.configs);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.configs, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigPb {
        ConfigPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "configs",
                |m: &ConfigPb| { &m.configs },
                |m: &mut ConfigPb| { &mut m.configs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigPb>(
                "ConfigPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigPb {
        static instance: ::protobuf::rt::LazyV2<ConfigPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigPb::new)
    }
}

impl ::protobuf::Clear for ConfigPb {
    fn clear(&mut self) {
        self.configs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BackupInfoPb {
    // message fields
    pub globalBackupId: i32,
    pub snapshotId: i64,
    pub graphDef: ::protobuf::SingularPtrField<GraphDefPb>,
    pub walOffsets: ::std::vec::Vec<i64>,
    pub partitionToBackupId: ::std::collections::HashMap<i32, i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BackupInfoPb {
    fn default() -> &'a BackupInfoPb {
        <BackupInfoPb as ::protobuf::Message>::default_instance()
    }
}

impl BackupInfoPb {
    pub fn new() -> BackupInfoPb {
        ::std::default::Default::default()
    }

    // int32 globalBackupId = 1;


    pub fn get_globalBackupId(&self) -> i32 {
        self.globalBackupId
    }
    pub fn clear_globalBackupId(&mut self) {
        self.globalBackupId = 0;
    }

    // Param is passed by value, moved
    pub fn set_globalBackupId(&mut self, v: i32) {
        self.globalBackupId = v;
    }

    // int64 snapshotId = 2;


    pub fn get_snapshotId(&self) -> i64 {
        self.snapshotId
    }
    pub fn clear_snapshotId(&mut self) {
        self.snapshotId = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshotId(&mut self, v: i64) {
        self.snapshotId = v;
    }

    // .GraphDefPb graphDef = 3;


    pub fn get_graphDef(&self) -> &GraphDefPb {
        self.graphDef.as_ref().unwrap_or_else(|| <GraphDefPb as ::protobuf::Message>::default_instance())
    }
    pub fn clear_graphDef(&mut self) {
        self.graphDef.clear();
    }

    pub fn has_graphDef(&self) -> bool {
        self.graphDef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graphDef(&mut self, v: GraphDefPb) {
        self.graphDef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graphDef(&mut self) -> &mut GraphDefPb {
        if self.graphDef.is_none() {
            self.graphDef.set_default();
        }
        self.graphDef.as_mut().unwrap()
    }

    // Take field
    pub fn take_graphDef(&mut self) -> GraphDefPb {
        self.graphDef.take().unwrap_or_else(|| GraphDefPb::new())
    }

    // repeated int64 walOffsets = 4;


    pub fn get_walOffsets(&self) -> &[i64] {
        &self.walOffsets
    }
    pub fn clear_walOffsets(&mut self) {
        self.walOffsets.clear();
    }

    // Param is passed by value, moved
    pub fn set_walOffsets(&mut self, v: ::std::vec::Vec<i64>) {
        self.walOffsets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_walOffsets(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.walOffsets
    }

    // Take field
    pub fn take_walOffsets(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.walOffsets, ::std::vec::Vec::new())
    }

    // repeated .BackupInfoPb.PartitionToBackupIdEntry partitionToBackupId = 5;


    pub fn get_partitionToBackupId(&self) -> &::std::collections::HashMap<i32, i32> {
        &self.partitionToBackupId
    }
    pub fn clear_partitionToBackupId(&mut self) {
        self.partitionToBackupId.clear();
    }

    // Param is passed by value, moved
    pub fn set_partitionToBackupId(&mut self, v: ::std::collections::HashMap<i32, i32>) {
        self.partitionToBackupId = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partitionToBackupId(&mut self) -> &mut ::std::collections::HashMap<i32, i32> {
        &mut self.partitionToBackupId
    }

    // Take field
    pub fn take_partitionToBackupId(&mut self) -> ::std::collections::HashMap<i32, i32> {
        ::std::mem::replace(&mut self.partitionToBackupId, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for BackupInfoPb {
    fn is_initialized(&self) -> bool {
        for v in &self.graphDef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.globalBackupId = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshotId = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.graphDef)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.walOffsets)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.partitionToBackupId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.globalBackupId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.globalBackupId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.snapshotId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.snapshotId, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.graphDef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.walOffsets {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(5, &self.partitionToBackupId);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.globalBackupId != 0 {
            os.write_int32(1, self.globalBackupId)?;
        }
        if self.snapshotId != 0 {
            os.write_int64(2, self.snapshotId)?;
        }
        if let Some(ref v) = self.graphDef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.walOffsets {
            os.write_int64(4, *v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(5, &self.partitionToBackupId, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BackupInfoPb {
        BackupInfoPb::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "globalBackupId",
                |m: &BackupInfoPb| { &m.globalBackupId },
                |m: &mut BackupInfoPb| { &mut m.globalBackupId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "snapshotId",
                |m: &BackupInfoPb| { &m.snapshotId },
                |m: &mut BackupInfoPb| { &mut m.snapshotId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GraphDefPb>>(
                "graphDef",
                |m: &BackupInfoPb| { &m.graphDef },
                |m: &mut BackupInfoPb| { &mut m.graphDef },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "walOffsets",
                |m: &BackupInfoPb| { &m.walOffsets },
                |m: &mut BackupInfoPb| { &mut m.walOffsets },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(
                "partitionToBackupId",
                |m: &BackupInfoPb| { &m.partitionToBackupId },
                |m: &mut BackupInfoPb| { &mut m.partitionToBackupId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BackupInfoPb>(
                "BackupInfoPb",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BackupInfoPb {
        static instance: ::protobuf::rt::LazyV2<BackupInfoPb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BackupInfoPb::new)
    }
}

impl ::protobuf::Clear for BackupInfoPb {
    fn clear(&mut self) {
        self.globalBackupId = 0;
        self.snapshotId = 0;
        self.graphDef.clear();
        self.walOffsets.clear();
        self.partitionToBackupId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BackupInfoPb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupInfoPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OpTypePb {
    MARKER = 0,
    OVERWRITE_VERTEX = 1,
    UPDATE_VERTEX = 2,
    DELETE_VERTEX = 3,
    OVERWRITE_EDGE = 4,
    UPDATE_EDGE = 5,
    DELETE_EDGE = 6,
    CREATE_VERTEX_TYPE = 7,
    CREATE_EDGE_TYPE = 8,
    ADD_EDGE_KIND = 9,
    DROP_VERTEX_TYPE = 10,
    DROP_EDGE_TYPE = 11,
    REMOVE_EDGE_KIND = 12,
    PREPARE_DATA_LOAD = 13,
    COMMIT_DATA_LOAD = 14,
}

impl ::protobuf::ProtobufEnum for OpTypePb {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OpTypePb> {
        match value {
            0 => ::std::option::Option::Some(OpTypePb::MARKER),
            1 => ::std::option::Option::Some(OpTypePb::OVERWRITE_VERTEX),
            2 => ::std::option::Option::Some(OpTypePb::UPDATE_VERTEX),
            3 => ::std::option::Option::Some(OpTypePb::DELETE_VERTEX),
            4 => ::std::option::Option::Some(OpTypePb::OVERWRITE_EDGE),
            5 => ::std::option::Option::Some(OpTypePb::UPDATE_EDGE),
            6 => ::std::option::Option::Some(OpTypePb::DELETE_EDGE),
            7 => ::std::option::Option::Some(OpTypePb::CREATE_VERTEX_TYPE),
            8 => ::std::option::Option::Some(OpTypePb::CREATE_EDGE_TYPE),
            9 => ::std::option::Option::Some(OpTypePb::ADD_EDGE_KIND),
            10 => ::std::option::Option::Some(OpTypePb::DROP_VERTEX_TYPE),
            11 => ::std::option::Option::Some(OpTypePb::DROP_EDGE_TYPE),
            12 => ::std::option::Option::Some(OpTypePb::REMOVE_EDGE_KIND),
            13 => ::std::option::Option::Some(OpTypePb::PREPARE_DATA_LOAD),
            14 => ::std::option::Option::Some(OpTypePb::COMMIT_DATA_LOAD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OpTypePb] = &[
            OpTypePb::MARKER,
            OpTypePb::OVERWRITE_VERTEX,
            OpTypePb::UPDATE_VERTEX,
            OpTypePb::DELETE_VERTEX,
            OpTypePb::OVERWRITE_EDGE,
            OpTypePb::UPDATE_EDGE,
            OpTypePb::DELETE_EDGE,
            OpTypePb::CREATE_VERTEX_TYPE,
            OpTypePb::CREATE_EDGE_TYPE,
            OpTypePb::ADD_EDGE_KIND,
            OpTypePb::DROP_VERTEX_TYPE,
            OpTypePb::DROP_EDGE_TYPE,
            OpTypePb::REMOVE_EDGE_KIND,
            OpTypePb::PREPARE_DATA_LOAD,
            OpTypePb::COMMIT_DATA_LOAD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OpTypePb>("OpTypePb", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OpTypePb {
}

impl ::std::default::Default for OpTypePb {
    fn default() -> Self {
        OpTypePb::MARKER
    }
}

impl ::protobuf::reflect::ProtobufValue for OpTypePb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TypeEnumPb {
    VERTEX = 0,
    EDGE = 1,
}

impl ::protobuf::ProtobufEnum for TypeEnumPb {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TypeEnumPb> {
        match value {
            0 => ::std::option::Option::Some(TypeEnumPb::VERTEX),
            1 => ::std::option::Option::Some(TypeEnumPb::EDGE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TypeEnumPb] = &[
            TypeEnumPb::VERTEX,
            TypeEnumPb::EDGE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TypeEnumPb>("TypeEnumPb", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TypeEnumPb {
}

impl ::std::default::Default for TypeEnumPb {
    fn default() -> Self {
        TypeEnumPb::VERTEX
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeEnumPb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fsdk/model.proto\x1a\x10sdk/common.proto\"r\n\x0bOperationPb\x12\"\
    \n\x0cpartitionKey\x18\x01\x20\x01(\x03R\x0cpartitionKey\x12!\n\x06opTyp\
    e\x18\x02\x20\x01(\x0e2\t.OpTypePbR\x06opType\x12\x1c\n\tdataBytes\x18\
    \x03\x20\x01(\x0cR\tdataBytes\"l\n\x10OperationBatchPb\x12*\n\x10latestS\
    napshotId\x18\x01\x20\x01(\x03R\x10latestSnapshotId\x12,\n\noperations\
    \x18\x02\x20\x03(\x0b2\x0c.OperationPbR\noperations\"_\n\nLogEntryPb\x12\
    \x1e\n\nsnapshotId\x18\x01\x20\x01(\x03R\nsnapshotId\x121\n\noperations\
    \x18\x02\x20\x01(\x0b2\x11.OperationBatchPbR\noperations\"\x13\n\x11Mark\
    erOperationPb\"L\n\x0fPropertyValuePb\x12'\n\x08dataType\x18\x01\x20\x01\
    (\x0e2\x0b.DataTypePbR\x08dataType\x12\x10\n\x03val\x18\x02\x20\x01(\x0c\
    R\x03val\"\x1c\n\nVertexIdPb\x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\
    \"`\n\x08EdgeIdPb\x12!\n\x05srcId\x18\x01\x20\x01(\x0b2\x0b.VertexIdPbR\
    \x05srcId\x12!\n\x05dstId\x18\x02\x20\x01(\x0b2\x0b.VertexIdPbR\x05dstId\
    \x12\x0e\n\x02id\x18\x03\x20\x01(\x03R\x02id\"\x1b\n\tLabelIdPb\x12\x0e\
    \n\x02id\x18\x01\x20\x01(\x05R\x02id\"\x98\x02\n\nEdgeKindPb\x12\x1c\n\t\
    edgeLabel\x18\x01\x20\x01(\tR\tedgeLabel\x12,\n\x0bedgeLabelId\x18\x02\
    \x20\x01(\x0b2\n.LabelIdPbR\x0bedgeLabelId\x12&\n\x0esrcVertexLabel\x18\
    \x03\x20\x01(\tR\x0esrcVertexLabel\x126\n\x10srcVertexLabelId\x18\x04\
    \x20\x01(\x0b2\n.LabelIdPbR\x10srcVertexLabelId\x12&\n\x0edstVertexLabel\
    \x18\x05\x20\x01(\tR\x0edstVertexLabel\x126\n\x10dstVertexLabelId\x18\
    \x06\x20\x01(\x0b2\n.LabelIdPbR\x10dstVertexLabelId\"S\n\x0eEdgeLocation\
    Pb\x12'\n\x08edgeKind\x18\x01\x20\x01(\x0b2\x0b.EdgeKindPbR\x08edgeKind\
    \x12\x18\n\x07forward\x18\x02\x20\x01(\x08R\x07forward\"\xce\x01\n\x0fDa\
    taOperationPb\x12\x18\n\x07keyBlob\x18\x01\x20\x01(\x0cR\x07keyBlob\x12\
    \"\n\x0clocationBlob\x18\x02\x20\x01(\x0cR\x0clocationBlob\x121\n\x05pro\
    ps\x18\x03\x20\x03(\x0b2\x1b.DataOperationPb.PropsEntryR\x05props\x1aJ\n\
    \nPropsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03key\x12&\n\x05val\
    ue\x18\x02\x20\x01(\x0b2\x10.PropertyValuePbR\x05value:\x028\x01\":\n\
    \x0fKindOperationPb\x12'\n\x08edgeKind\x18\x01\x20\x01(\x0b2\x0b.EdgeKin\
    dPbR\x08edgeKind\"\xb4\x01\n\tTypeDefPb\x12\x1c\n\tversionId\x18\x01\x20\
    \x01(\x05R\tversionId\x12\x14\n\x05label\x18\x02\x20\x01(\tR\x05label\
    \x12$\n\x07labelId\x18\x03\x20\x01(\x0b2\n.LabelIdPbR\x07labelId\x12'\n\
    \x08typeEnum\x18\x04\x20\x01(\x0e2\x0b.TypeEnumPbR\x08typeEnum\x12$\n\
    \x05props\x18\x05\x20\x03(\x0b2\x0e.PropertyDefPbR\x05props\"\xd6\x01\n\
    \rPropertyDefPb\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x18\n\
    \x07innerId\x18\x02\x20\x01(\x05R\x07innerId\x12\x12\n\x04name\x18\x03\
    \x20\x01(\tR\x04name\x12'\n\x08dataType\x18\x04\x20\x01(\x0e2\x0b.DataTy\
    pePbR\x08dataType\x124\n\x0cdefaultValue\x18\x05\x20\x01(\x0b2\x10.Prope\
    rtyValuePbR\x0cdefaultValue\x12\x0e\n\x02pk\x18\x06\x20\x01(\x08R\x02pk\
    \x12\x18\n\x07comment\x18\x07\x20\x01(\tR\x07comment\"M\n\x0cDdlRequestP\
    b\x12!\n\x06opType\x18\x01\x20\x01(\x0e2\t.OpTypePbR\x06opType\x12\x1a\n\
    \x08ddlBytes\x18\x02\x20\x01(\x0cR\x08ddlBytes\"D\n\x11DdlRequestBatchPb\
    \x12/\n\x0bddlRequests\x18\x01\x20\x03(\x0b2\r.DdlRequestPbR\x0bddlReque\
    sts\"P\n\x0eDdlOperationPb\x12$\n\rschemaVersion\x18\x01\x20\x01(\x03R\r\
    schemaVersion\x12\x18\n\x07ddlBlob\x18\x02\x20\x01(\x0cR\x07ddlBlob\"V\n\
    \x12CreateVertexTypePb\x12$\n\x07typeDef\x18\x01\x20\x01(\x0b2\n.TypeDef\
    PbR\x07typeDef\x12\x1a\n\x08tableIdx\x18\x02\x20\x01(\x03R\x08tableIdx\"\
    T\n\rAddEdgeKindPb\x12'\n\x08edgeKind\x18\x01\x20\x01(\x0b2\x0b.EdgeKind\
    PbR\x08edgeKind\x12\x1a\n\x08tableIdx\x18\x02\x20\x01(\x03R\x08tableIdx\
    \"U\n\x10EdgeTableIdEntry\x12'\n\x08edgeKind\x18\x01\x20\x01(\x0b2\x0b.E\
    dgeKindPbR\x08edgeKind\x12\x18\n\x07tableId\x18\x02\x20\x01(\x03R\x07tab\
    leId\"T\n\x12VertexTableIdEntry\x12$\n\x07labelId\x18\x01\x20\x01(\x0b2\
    \n.LabelIdPbR\x07labelId\x12\x18\n\x07tableId\x18\x02\x20\x01(\x03R\x07t\
    ableId\"\xdb\x03\n\nGraphDefPb\x12\x18\n\x07version\x18\x01\x20\x01(\x03\
    R\x07version\x12&\n\x08typeDefs\x18\x02\x20\x03(\x0b2\n.TypeDefPbR\x08ty\
    peDefs\x12)\n\tedgeKinds\x18\x03\x20\x03(\x0b2\x0b.EdgeKindPbR\tedgeKind\
    s\x12M\n\x10propertyNameToId\x18\x04\x20\x03(\x0b2!.GraphDefPb.PropertyN\
    ameToIdEntryR\x10propertyNameToId\x12\x1a\n\x08labelIdx\x18\x05\x20\x01(\
    \x05R\x08labelIdx\x12\x20\n\x0bpropertyIdx\x18\x06\x20\x01(\x05R\x0bprop\
    ertyIdx\x12;\n\x0evertexTableIds\x18\x07\x20\x03(\x0b2\x13.VertexTableId\
    EntryR\x0evertexTableIds\x125\n\x0cedgeTableIds\x18\x08\x20\x03(\x0b2\
    \x11.EdgeTableIdEntryR\x0cedgeTableIds\x12\x1a\n\x08tableIdx\x18\t\x20\
    \x01(\x03R\x08tableIdx\x1aC\n\x15PropertyNameToIdEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05\
    value:\x028\x01\"k\n\x0fStorePropertyPb\x12\x1f\n\x0bproperty_id\x18\x01\
    \x20\x01(\x05R\npropertyId\x127\n\x0eproperty_value\x18\x02\x20\x01(\x0b\
    2\x10.PropertyValuePbR\rpropertyValue\"G\n\x13StorePropertyListPb\x120\n\
    \nproperties\x18\x01\x20\x03(\x0b2\x10.StorePropertyPbR\nproperties\"x\n\
    \x08ConfigPb\x120\n\x07configs\x18\x01\x20\x03(\x0b2\x16.ConfigPb.Config\
    sEntryR\x07configs\x1a:\n\x0cConfigsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"\xc1\x02\n\x0cBackupInfoPb\x12&\n\x0eglobalBackupId\x18\x01\x20\
    \x01(\x05R\x0eglobalBackupId\x12\x1e\n\nsnapshotId\x18\x02\x20\x01(\x03R\
    \nsnapshotId\x12'\n\x08graphDef\x18\x03\x20\x01(\x0b2\x0b.GraphDefPbR\
    \x08graphDef\x12\x1e\n\nwalOffsets\x18\x04\x20\x03(\x03R\nwalOffsets\x12\
    X\n\x13partitionToBackupId\x18\x05\x20\x03(\x0b2&.BackupInfoPb.Partition\
    ToBackupIdEntryR\x13partitionToBackupId\x1aF\n\x18PartitionToBackupIdEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x05R\x05value:\x028\x01*\xb6\x02\n\x08OpTypePb\x12\n\n\x06\
    MARKER\x10\0\x12\x14\n\x10OVERWRITE_VERTEX\x10\x01\x12\x11\n\rUPDATE_VER\
    TEX\x10\x02\x12\x11\n\rDELETE_VERTEX\x10\x03\x12\x12\n\x0eOVERWRITE_EDGE\
    \x10\x04\x12\x0f\n\x0bUPDATE_EDGE\x10\x05\x12\x0f\n\x0bDELETE_EDGE\x10\
    \x06\x12\x16\n\x12CREATE_VERTEX_TYPE\x10\x07\x12\x14\n\x10CREATE_EDGE_TY\
    PE\x10\x08\x12\x11\n\rADD_EDGE_KIND\x10\t\x12\x14\n\x10DROP_VERTEX_TYPE\
    \x10\n\x12\x12\n\x0eDROP_EDGE_TYPE\x10\x0b\x12\x14\n\x10REMOVE_EDGE_KIND\
    \x10\x0c\x12\x15\n\x11PREPARE_DATA_LOAD\x10\r\x12\x14\n\x10COMMIT_DATA_L\
    OAD\x10\x0e*\"\n\nTypeEnumPb\x12\n\n\x06VERTEX\x10\0\x12\x08\n\x04EDGE\
    \x10\x01B$\n\x20com.alibaba.maxgraph.proto.grootP\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
